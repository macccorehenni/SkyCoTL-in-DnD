/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ColorCycler
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_COLOR = {
  h: 0,
  s: 100,
  l: 50
};
var DEFAULT_THEME_SETTINGS = {
  color: DEFAULT_COLOR,
  behavior: "increment" /* INCREMENT */,
  timer: {
    isTimerEnabled: false,
    timerSeconds: ""
  },
  shouldCycleColorOnLoad: false,
  increment: {
    startAngle: 0,
    degrees: 30,
    saturation: DEFAULT_COLOR["s"],
    lightness: DEFAULT_COLOR["l"]
  },
  random: {
    isHueRandom: true,
    isSaturationRandom: false,
    isLightnessRandom: false,
    hue: DEFAULT_COLOR["h"],
    saturation: DEFAULT_COLOR["s"],
    lightness: DEFAULT_COLOR["l"]
  },
  preset: {
    currentPresetIndex: 0,
    colorList: [DEFAULT_COLOR]
  }
};
var DEFAULT_SETTINGS = {
  shouldShowStatusBar: false,
  shouldUseSeparateThemeSettings: false,
  themes: {
    base: DEFAULT_THEME_SETTINGS,
    dark: DEFAULT_THEME_SETTINGS,
    light: DEFAULT_THEME_SETTINGS
  }
};
function bound(value, min, max) {
  return !Number.isNaN(value) ? Math.min(Math.max(value, min), max) : min;
}
var ColorCycler = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.lastSave = void 0;
    this.themeMode = "base" /* BASE */;
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "cycle-color",
      name: "Cycle accent color",
      callback: () => {
        this.cycleColor();
      }
    });
    this.ribbonIconEl = this.addRibbonIcon("palette", "Cycle accent color", () => {
      this.cycleColor();
    });
    this.statusBarItemEl = this.addStatusBarItem();
    this.addSettingTab(new ColorCyclerSettingTab(this.app, this));
    this.update();
    this.registerEvent(this.app.workspace.on("css-change", this.detectTheme.bind(this)));
    this.detectTheme();
    if (this.settings.themes[this.themeMode].shouldCycleColorOnLoad) {
      this.cycleColor();
    }
  }
  update() {
    this.updateColor(this.settings.themes[this.themeMode].color);
    this.updateTimer();
    this.updateStatusBar();
    this.updateStatusBarVisibility();
  }
  detectTheme() {
    if (!this.settings.shouldUseSeparateThemeSettings) {
      this.themeMode = "base" /* BASE */;
    } else {
      const theme = this.app.getTheme();
      const media = window.matchMedia("(prefers-color-scheme: dark)");
      let newThemeMode = "base" /* BASE */;
      if (theme === "obsidian") {
        newThemeMode = "dark" /* DARK */;
      } else if (theme === "moonstone") {
        newThemeMode = "light" /* LIGHT */;
      } else if (theme === "system" && media.matches) {
        newThemeMode = "dark" /* DARK */;
      } else if (theme === "system" && !media.matches) {
        newThemeMode = "light" /* LIGHT */;
      }
      if (newThemeMode !== this.themeMode) {
        this.themeMode = newThemeMode;
      }
    }
    this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getThemeSettings(savedData, mode) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    return {
      color: (_b = (_a = savedData == null ? void 0 : savedData.themes[mode]) == null ? void 0 : _a.color) != null ? _b : DEFAULT_SETTINGS.themes[mode].color,
      behavior: (_d = (_c = savedData == null ? void 0 : savedData.themes[mode]) == null ? void 0 : _c.behavior) != null ? _d : DEFAULT_SETTINGS.themes[mode].behavior,
      shouldCycleColorOnLoad: (_f = (_e = savedData == null ? void 0 : savedData.themes[mode]) == null ? void 0 : _e.shouldCycleColorOnLoad) != null ? _f : DEFAULT_SETTINGS.themes[mode].shouldCycleColorOnLoad,
      timer: {
        ...DEFAULT_SETTINGS.themes[mode].timer,
        ...(_g = savedData == null ? void 0 : savedData.themes[mode]) == null ? void 0 : _g.timer
      },
      increment: {
        ...DEFAULT_SETTINGS.themes[mode].increment,
        ...(_h = savedData == null ? void 0 : savedData.themes[mode]) == null ? void 0 : _h.increment
      },
      random: {
        ...DEFAULT_SETTINGS.themes[mode].random,
        ...(_i = savedData == null ? void 0 : savedData.themes[mode]) == null ? void 0 : _i.random
      },
      preset: {
        ...DEFAULT_SETTINGS.themes[mode].preset,
        ...(_j = savedData == null ? void 0 : savedData.themes[mode]) == null ? void 0 : _j.preset
      }
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async migrateBaseThemeSettings(savedData) {
    var _a, _b, _c;
    if (!savedData || savedData.themes)
      return savedData;
    if (savedData.behavior || savedData.timer || savedData.increment || savedData.random || savedData.preset) {
      this.settings.themes.base = {
        color: (_a = savedData == null ? void 0 : savedData.color) != null ? _a : DEFAULT_SETTINGS.themes.base.color,
        behavior: (_b = savedData == null ? void 0 : savedData.behavior) != null ? _b : DEFAULT_SETTINGS.themes.base.behavior,
        shouldCycleColorOnLoad: (_c = savedData == null ? void 0 : savedData.shouldCycleColorOnLoad) != null ? _c : DEFAULT_SETTINGS.themes.base.shouldCycleColorOnLoad,
        timer: {
          ...DEFAULT_SETTINGS.themes.base.timer,
          ...savedData == null ? void 0 : savedData.timer
        },
        increment: {
          ...DEFAULT_SETTINGS.themes.base.increment,
          ...savedData == null ? void 0 : savedData.increment
        },
        random: {
          ...DEFAULT_SETTINGS.themes.base.random,
          ...savedData == null ? void 0 : savedData.random
        },
        preset: {
          ...DEFAULT_SETTINGS.themes.base.preset,
          ...savedData == null ? void 0 : savedData.preset
        }
      };
      delete this.settings.color;
      delete this.settings.behavior;
      delete this.settings.timer;
      delete this.settings.increment;
      delete this.settings.random;
      delete this.settings.preset;
      await this.saveSettings();
      return await this.loadData();
    }
  }
  async loadSettings() {
    const savedData = await this.loadData();
    const migratedSavedData = await this.migrateBaseThemeSettings(savedData);
    this.settings = {
      ...DEFAULT_SETTINGS,
      ...migratedSavedData,
      themes: {
        ["base" /* BASE */]: this.getThemeSettings(migratedSavedData, "base" /* BASE */),
        ["dark" /* DARK */]: this.getThemeSettings(migratedSavedData, "dark" /* DARK */),
        ["light" /* LIGHT */]: this.getThemeSettings(migratedSavedData, "light" /* LIGHT */)
      }
    };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  updateStatusBarVisibility() {
    if (this.settings.shouldShowStatusBar) {
      this.statusBarItemEl.show();
    } else {
      this.statusBarItemEl.hide();
    }
  }
  updateStatusBar() {
    this.statusBarItemEl.setText(
      `HSL ${this.settings.themes[this.themeMode].color.h} ${this.settings.themes[this.themeMode].color.s} ${this.settings.themes[this.themeMode].color.l}`
    );
  }
  updateTimer() {
    clearInterval(this.timerId);
    if (this.settings.themes[this.themeMode].timer.isTimerEnabled && this.settings.themes[this.themeMode].timer.timerSeconds) {
      const timerSeconds = bound(
        this.settings.themes[this.themeMode].timer.timerSeconds || NaN,
        1 /* MIN */,
        86400 /* MAX */
      );
      this.timerId = this.registerInterval(window.setInterval(() => this.cycleColor(true), timerSeconds * 1e3));
    }
  }
  async setColor(color, isTimer = false) {
    const hue = color.h % 360;
    const saturation = bound(color.s, 0 /* MIN */, 100 /* MAX */);
    const lightness = bound(color.l, 0 /* MIN */, 100 /* MAX */);
    this.settings.themes[this.themeMode].color = { h: hue, s: saturation, l: lightness };
    this.updateColor(this.settings.themes[this.themeMode].color);
    this.updateStatusBar();
    if (isTimer) {
      if (this.lastSave) {
        const now = Date.now();
        if (now - this.lastSave > 60 * 1e3) {
          await this.saveSettings();
          this.lastSave = now;
        }
      } else {
        await this.saveSettings();
        this.lastSave = Date.now();
      }
    } else {
      this.updateTimer();
      await this.saveSettings();
    }
  }
  updateColor(color) {
    document.body.style.setProperty("--accent-h", `${color.h}`);
    document.body.style.setProperty("--accent-s", `${color.s}%`);
    document.body.style.setProperty("--accent-l", `${color.l}%`);
  }
  incrementColor(isTimer = false) {
    const currentHue = this.settings.themes[this.themeMode].color.h;
    const degrees = this.settings.themes[this.themeMode].increment.degrees;
    const newHue = currentHue + degrees;
    this.setColor(
      {
        h: newHue,
        s: this.settings.themes[this.themeMode].increment.saturation,
        l: this.settings.themes[this.themeMode].increment.lightness
      },
      isTimer
    );
  }
  randomizeColor(isTimer = false) {
    const hue = this.settings.themes[this.themeMode].random.isHueRandom ? Math.floor(Math.random() * 360 /* MAX */) : this.settings.themes[this.themeMode].random.hue;
    const saturation = this.settings.themes[this.themeMode].random.isSaturationRandom ? Math.floor(Math.random() * 100 /* MAX */) : this.settings.themes[this.themeMode].random.saturation;
    const lightness = this.settings.themes[this.themeMode].random.isLightnessRandom ? Math.floor(Math.random() * 100 /* MAX */) : this.settings.themes[this.themeMode].random.lightness;
    this.setColor(
      {
        h: hue,
        s: saturation,
        l: lightness
      },
      isTimer
    );
  }
  cyclePresetColor(isTimer = false) {
    var _a;
    const nextPresetIndex = this.settings.themes[this.themeMode].preset.currentPresetIndex + 1 >= this.settings.themes[this.themeMode].preset.colorList.length ? 0 : this.settings.themes[this.themeMode].preset.currentPresetIndex + 1;
    this.settings.themes[this.themeMode].preset.currentPresetIndex = nextPresetIndex;
    this.setColor(
      (_a = this.settings.themes[this.themeMode].preset.colorList[nextPresetIndex]) != null ? _a : this.settings.themes[this.themeMode].color,
      isTimer
    );
  }
  cycleColor(isTimer = false) {
    switch (this.settings.themes[this.themeMode].behavior) {
      case "increment" /* INCREMENT */:
        this.incrementColor(isTimer);
        break;
      case "random" /* RANDOM */:
        this.randomizeColor(isTimer);
        break;
      case "preset" /* PRESET */:
        this.cyclePresetColor(isTimer);
        break;
      default:
    }
  }
};
var ColorCyclerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  showColorSettings(containerEl, themeMode) {
    new import_obsidian.Setting(containerEl).setName("Behavior").setDesc("How the accent color is cycled when clicking the sidebar button.").addExtraButton(
      (button) => button.setIcon("gear").setTooltip("Advanced settings").onClick(() => {
        new BehaviorModal(this.app, this.plugin, themeMode).open();
      })
    ).addDropdown(
      (dropdown) => dropdown.addOptions({
        ["increment" /* INCREMENT */]: "Increment",
        ["random" /* RANDOM */]: "Random",
        ["preset" /* PRESET */]: "Preset"
      }).setValue(this.plugin.settings.themes[themeMode].behavior).onChange(async (value) => {
        this.plugin.settings.themes[themeMode].behavior = value;
        if (themeMode === this.plugin.themeMode) {
          switch (this.plugin.settings.themes[themeMode].behavior) {
            case "increment" /* INCREMENT */:
              this.plugin.setColor({
                h: this.plugin.settings.themes[themeMode].increment.startAngle,
                s: this.plugin.settings.themes[themeMode].increment.saturation,
                l: this.plugin.settings.themes[themeMode].increment.lightness
              });
              break;
            case "random" /* RANDOM */:
              this.plugin.randomizeColor();
              break;
            case "preset" /* PRESET */:
              if (this.plugin.settings.themes[themeMode].preset.colorList[this.plugin.settings.themes[themeMode].preset.currentPresetIndex]) {
                this.plugin.setColor(
                  this.plugin.settings.themes[themeMode].preset.colorList[this.plugin.settings.themes[themeMode].preset.currentPresetIndex]
                );
              }
              break;
            default:
          }
        }
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Timer").setDesc(
      "Automatically cycle the color after a specified time in seconds. Manually cycling the color will reset the timer."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.themes[themeMode].timer.isTimerEnabled).onChange(async (value) => {
        this.plugin.settings.themes[themeMode].timer.isTimerEnabled = value;
        if (themeMode === this.plugin.themeMode) {
          this.plugin.updateTimer();
        }
        await this.plugin.saveSettings();
        this.display();
      })
    ).addText(
      (text) => text.setPlaceholder("1-86400").setDisabled(!this.plugin.settings.themes[themeMode].timer.isTimerEnabled).setValue(this.plugin.settings.themes[themeMode].timer.timerSeconds.toString()).onChange(async (value) => {
        const newValue = value !== "" ? bound(parseInt(value), 1 /* MIN */, 86400 /* MAX */) : value;
        this.plugin.settings.themes[themeMode].timer.timerSeconds = newValue;
        if (themeMode === this.plugin.themeMode) {
          this.plugin.updateTimer();
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Cycle color on load").setDesc("Automatically cycle the color when the vault opens.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.themes[themeMode].shouldCycleColorOnLoad).onChange(async (value) => {
        this.plugin.settings.themes[themeMode].shouldCycleColorOnLoad = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Show in status bar").setDesc("Show or hide the HSL value in the status bar.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.shouldShowStatusBar).onChange(async (value) => {
        this.plugin.settings.shouldShowStatusBar = value;
        this.plugin.updateStatusBarVisibility();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Separate theme settings").setDesc("Set cycle behavior for the dark and light themes individually.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.shouldUseSeparateThemeSettings).onChange(async (value) => {
        this.plugin.settings.shouldUseSeparateThemeSettings = value;
        await this.plugin.saveSettings();
        this.display();
        this.plugin.detectTheme();
      })
    );
    if (this.plugin.settings.shouldUseSeparateThemeSettings) {
      new import_obsidian.Setting(containerEl).setName("Dark theme colors").setHeading();
      this.showColorSettings(containerEl, "dark" /* DARK */);
      new import_obsidian.Setting(containerEl).setName("Light theme colors").setHeading();
      this.showColorSettings(containerEl, "light" /* LIGHT */);
    } else {
      new import_obsidian.Setting(containerEl).setName("Colors").setHeading();
      this.showColorSettings(containerEl, "base" /* BASE */);
    }
  }
};
var BehaviorModal = class extends import_obsidian.Modal {
  constructor(app, plugin, themeMode) {
    super(app);
    this.plugin = plugin;
    this.themeMode = themeMode;
  }
  onOpen() {
    const { contentEl } = this;
    switch (this.plugin.settings.themes[this.themeMode].behavior) {
      case "increment" /* INCREMENT */:
        this.showIncrementSettings(contentEl);
        break;
      case "random" /* RANDOM */:
        this.showRandomSettings(contentEl);
        break;
      case "preset" /* PRESET */:
        this.showPresetSettings(contentEl);
        break;
      default:
        contentEl.createEl("p", { text: "No behavior selected" });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  refresh() {
    this.onClose();
    this.onOpen();
  }
  showIncrementSettings(contentEl) {
    new import_obsidian.Setting(contentEl).setName("Increment").setHeading();
    new import_obsidian.Setting(contentEl).setName("Starting hue angle").setDesc("Hue angle on the color wheel to start incrementing from.").addSlider(
      (slider) => slider.setLimits(0 /* MIN */, 360 /* MAX */, 1).setDynamicTooltip().setValue(this.plugin.settings.themes[this.themeMode].increment.startAngle).onChange(async (value) => {
        this.plugin.settings.themes[this.themeMode].increment.startAngle = value;
        if (this.themeMode === this.plugin.themeMode) {
          this.plugin.setColor({
            h: this.plugin.settings.themes[this.themeMode].increment.startAngle,
            s: this.plugin.settings.themes[this.themeMode].increment.saturation,
            l: this.plugin.settings.themes[this.themeMode].increment.lightness
          });
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Hue increment degrees").setDesc("Hue angle degrees of the color wheel to advance on each click.").addSlider(
      (slider) => slider.setLimits(0 /* MIN */ + 1, 360 /* MAX */, 1).setDynamicTooltip().setValue(this.plugin.settings.themes[this.themeMode].increment.degrees).onChange(async (value) => {
        this.plugin.settings.themes[this.themeMode].increment.degrees = value;
        if (this.themeMode === this.plugin.themeMode) {
          this.plugin.setColor({
            h: this.plugin.settings.themes[this.themeMode].increment.startAngle,
            s: this.plugin.settings.themes[this.themeMode].increment.saturation,
            l: this.plugin.settings.themes[this.themeMode].increment.lightness
          });
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Saturation").setDesc("Static saturation percentage.").addSlider(
      (slider) => slider.setLimits(0 /* MIN */, 100 /* MAX */, 1).setDynamicTooltip().setValue(this.plugin.settings.themes[this.themeMode].increment.saturation).onChange(async (value) => {
        this.plugin.settings.themes[this.themeMode].increment.saturation = value;
        if (this.themeMode === this.plugin.themeMode) {
          this.plugin.setColor({
            h: this.plugin.settings.themes[this.themeMode].increment.startAngle,
            s: this.plugin.settings.themes[this.themeMode].increment.saturation,
            l: this.plugin.settings.themes[this.themeMode].increment.lightness
          });
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Lightness").setDesc("Static lightness percentage.").addSlider(
      (slider) => slider.setLimits(0 /* MIN */, 100 /* MAX */, 1).setDynamicTooltip().setValue(this.plugin.settings.themes[this.themeMode].increment.lightness).onChange(async (value) => {
        this.plugin.settings.themes[this.themeMode].increment.lightness = value;
        if (this.themeMode === this.plugin.themeMode) {
          this.plugin.setColor({
            h: this.plugin.settings.themes[this.themeMode].increment.startAngle,
            s: this.plugin.settings.themes[this.themeMode].increment.saturation,
            l: this.plugin.settings.themes[this.themeMode].increment.lightness
          });
        }
        await this.plugin.saveSettings();
      })
    );
  }
  showRandomSettings(contentEl) {
    new import_obsidian.Setting(contentEl).setName("Random").setHeading();
    new import_obsidian.Setting(contentEl).setName("Randomize hue").setDesc("Randomize hue angle on each click. Otherwise, use the slider to set a static hue angle.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.themes[this.themeMode].random.isHueRandom).onChange(async (value) => {
        this.plugin.settings.themes[this.themeMode].random.isHueRandom = value;
        await this.plugin.saveSettings();
        this.refresh();
      })
    ).addSlider(
      (slider) => slider.setLimits(0 /* MIN */, 360 /* MAX */, 1).setDynamicTooltip().setDisabled(this.plugin.settings.themes[this.themeMode].random.isHueRandom).setValue(this.plugin.settings.themes[this.themeMode].random.hue).onChange(async (value) => {
        this.plugin.settings.themes[this.themeMode].random.hue = value;
        if (this.themeMode === this.plugin.themeMode) {
          this.plugin.setColor({
            h: this.plugin.settings.themes[this.themeMode].random.hue,
            s: this.plugin.settings.themes[this.themeMode].random.saturation,
            l: this.plugin.settings.themes[this.themeMode].random.lightness
          });
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Randomize saturation").setDesc(
      "Randomize saturation percentage on each click. Otherwise, use the slider to set a static saturation percentage."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.themes[this.themeMode].random.isSaturationRandom).onChange(async (value) => {
        this.plugin.settings.themes[this.themeMode].random.isSaturationRandom = value;
        await this.plugin.saveSettings();
        this.refresh();
      })
    ).addSlider(
      (slider) => slider.setLimits(0 /* MIN */, 100 /* MAX */, 1).setDynamicTooltip().setDisabled(this.plugin.settings.themes[this.themeMode].random.isSaturationRandom).setValue(this.plugin.settings.themes[this.themeMode].random.saturation).onChange(async (value) => {
        this.plugin.settings.themes[this.themeMode].random.saturation = value;
        if (this.themeMode === this.plugin.themeMode) {
          this.plugin.setColor({
            h: this.plugin.settings.themes[this.themeMode].random.hue,
            s: this.plugin.settings.themes[this.themeMode].random.saturation,
            l: this.plugin.settings.themes[this.themeMode].random.lightness
          });
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Randomize lightness").setDesc(
      "Randomize lightness percentage on each click. Otherwise, use the slider to set a static lightness percentage."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.themes[this.themeMode].random.isLightnessRandom).onChange(async (value) => {
        this.plugin.settings.themes[this.themeMode].random.isLightnessRandom = value;
        await this.plugin.saveSettings();
        this.refresh();
      })
    ).addSlider(
      (slider) => slider.setLimits(0 /* MIN */, 100 /* MAX */, 1).setDynamicTooltip().setDisabled(this.plugin.settings.themes[this.themeMode].random.isLightnessRandom).setValue(this.plugin.settings.themes[this.themeMode].random.lightness).onChange(async (value) => {
        this.plugin.settings.themes[this.themeMode].random.lightness = value;
        if (this.themeMode === this.plugin.themeMode) {
          this.plugin.setColor({
            h: this.plugin.settings.themes[this.themeMode].random.hue,
            s: this.plugin.settings.themes[this.themeMode].random.saturation,
            l: this.plugin.settings.themes[this.themeMode].random.lightness
          });
        }
        await this.plugin.saveSettings();
      })
    );
  }
  showPresetSettings(contentEl) {
    new import_obsidian.Setting(contentEl).setName("Preset").setHeading();
    new import_obsidian.Setting(contentEl).setHeading().setName("Colors").addExtraButton(
      (button) => button.setIcon("plus-circle").setTooltip("Add color").onClick(() => {
        this.plugin.settings.themes[this.themeMode].preset.colorList.push({
          h: 0,
          s: 100,
          l: 50
        });
        this.plugin.saveSettings();
        this.refresh();
      })
    );
    this.plugin.settings.themes[this.themeMode].preset.colorList.forEach((_colorPreset, index) => {
      new import_obsidian.Setting(contentEl).setName(`Color ${index + 1}`).addExtraButton(
        (button) => button.setIcon("palette").setTooltip("Set as current color").onClick(async () => {
          this.plugin.settings.themes[this.themeMode].preset.currentPresetIndex = index;
          if (this.themeMode === this.plugin.themeMode) {
            this.plugin.setColor(
              this.plugin.settings.themes[this.themeMode].preset.colorList[this.plugin.settings.themes[this.themeMode].preset.currentPresetIndex]
            );
          }
          await this.plugin.saveSettings();
        }).setDisabled(this.themeMode !== this.plugin.themeMode)
      ).addExtraButton(
        (button) => button.setIcon("trash").setTooltip("Remove color").setDisabled(this.plugin.settings.themes[this.themeMode].preset.colorList.length === 1 && index === 0).onClick(async () => {
          this.plugin.settings.themes[this.themeMode].preset.colorList = [
            ...this.plugin.settings.themes[this.themeMode].preset.colorList.slice(0, index),
            ...this.plugin.settings.themes[this.themeMode].preset.colorList.slice(
              index + 1,
              this.plugin.settings.themes[this.themeMode].preset.colorList.length
            )
          ];
          this.plugin.settings.themes[this.themeMode].preset.currentPresetIndex = 0;
          if (this.themeMode === this.plugin.themeMode) {
            this.plugin.setColor(
              this.plugin.settings.themes[this.themeMode].preset.colorList[this.plugin.settings.themes[this.themeMode].preset.currentPresetIndex]
            );
          }
          await this.plugin.saveSettings();
          this.refresh();
        })
      ).addColorPicker((color) => {
        color.setValueHsl(this.plugin.settings.themes[this.themeMode].preset.colorList[index]);
        color.onChange(async () => {
          this.plugin.settings.themes[this.themeMode].preset.colorList[index] = color.getValueHsl();
          this.plugin.settings.themes[this.themeMode].preset.currentPresetIndex = index;
          if (this.themeMode === this.plugin.themeMode) {
            this.plugin.setColor(
              this.plugin.settings.themes[this.themeMode].preset.colorList[this.plugin.settings.themes[this.themeMode].preset.currentPresetIndex]
            );
          }
          await this.plugin.saveSettings();
        });
      });
    });
  }
};

/* nosourcemap */