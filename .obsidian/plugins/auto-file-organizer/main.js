/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoFileMovePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  tagEnabled: false,
  extensionEnabled: false,
  priority: "tag",
  folderMapping: {},
  tagMapping: {}
};
var AutoFileMovePlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Auto File Organizer loaded!");
    await this.loadSettings();
    this.addSettingTab(new AutoFileMoveSettingTab(this.app, this));
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        if (Object.keys(this.settings.folderMapping).length > 0) {
          await this.handleFile(file);
        } else {
          console.log("No folder mapping defined. Skipping file organization.");
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        if (!(file instanceof import_obsidian.TFile))
          return;
        const isInRoot = !file.path.includes("/");
        if (!isInRoot)
          return;
        await this.handleFile(file);
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", async (file) => {
        await this.handleFile(file);
      })
    );
    this.addCommand({
      id: "organize-files",
      name: "Organize Files",
      callback: async () => {
        await this.organizeVault();
        new import_obsidian.Notice("Files organized");
      }
    });
  }
  async handleFile(file) {
    if (!(file instanceof import_obsidian.TFile))
      return null;
    const originalPath = file.path;
    const moveByTag = async () => {
      if (!this.settings.tagEnabled)
        return false;
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!metadata) {
        console.log(`No metadata found for file: ${file.path}`);
        return false;
      }
      const tags = (0, import_obsidian.getAllTags)(metadata);
      if (tags && tags.length > 0) {
        for (const tag of tags) {
          const targetFolder = this.settings.tagMapping[tag];
          if (targetFolder) {
            await this.ensureFolderExists(targetFolder);
            const targetPath = `${targetFolder}/${file.name}`;
            if (originalPath !== targetPath) {
              try {
                await this.app.vault.rename(file, targetPath);
                return true;
              } catch (err) {
                console.error(`Failed to move file ${file.name} by tag:`, err);
              }
            }
          }
        }
      }
      return false;
    };
    const moveByExtension = async () => {
      if (!this.settings.extensionEnabled)
        return false;
      const extension = file.extension;
      const targetFolder = this.settings.folderMapping[extension];
      if (targetFolder) {
        await this.ensureFolderExists(targetFolder);
        const targetPath = `${targetFolder}/${file.name}`;
        if (originalPath !== targetPath) {
          try {
            await this.app.vault.rename(file, targetPath);
            return true;
          } catch (err) {
            console.error(`Failed to move file ${file.name} by extension:`, err);
          }
        }
      }
      return false;
    };
    if (this.settings.priority === "tag") {
      const movedByTag = await moveByTag();
      if (movedByTag)
        return file.name;
      const movedByExtension = await moveByExtension();
      return movedByExtension ? file.name : null;
    } else if (this.settings.priority === "extension") {
      const movedByExtension = await moveByExtension();
      if (movedByExtension)
        return file.name;
      const movedByTag = await moveByTag();
      return movedByTag ? file.name : null;
    }
    console.log(`No suitable folder mapping found for file: ${file.name}`);
    return null;
  }
  async ensureFolderExists(folderPath) {
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (Object.keys(this.settings.folderMapping).length > 0) {
      await this.organizeVault();
    }
  }
  async organizeVault() {
    const files = this.app.vault.getFiles();
    const movedFiles = [];
    const promises = files.map(async (file) => {
      const moved = await this.handleFile(file);
      if (moved) {
        movedFiles.push(moved);
      }
    });
    await Promise.all(promises);
    if (movedFiles.length > 0) {
      new import_obsidian.Notice(`Moved ${movedFiles.length} files:
${movedFiles.join(", ")}`);
    } else {
      new import_obsidian.Notice("No files were moved.");
    }
  }
  async updateTagMappingFromExistingFiles() {
    var _a, _b;
    const allFiles = this.app.vault.getFiles();
    const tagToFolderMap = {};
    for (const file of allFiles) {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!metadata)
        continue;
      const tags = (0, import_obsidian.getAllTags)(metadata);
      if (tags && tags.length > 0) {
        for (const tag of tags) {
          const folderName = ((_b = (_a = this.app.vault.getAbstractFileByPath(file.path)) == null ? void 0 : _a.parent) == null ? void 0 : _b.name) || "DefaultFolder";
          if (!tagToFolderMap[tag]) {
            tagToFolderMap[tag] = folderName;
          }
        }
      }
    }
    this.settings.tagMapping = {
      ...this.settings.tagMapping,
      ...tagToFolderMap
    };
    await this.saveSettings();
    new import_obsidian.Notice(`update tag-to-folder mapping.`);
  }
};
var AutoFileMoveSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Priority").setDesc("Decide which mapping takes precedence when both are enabled.").addDropdown((dropdown) => {
      dropdown.addOptions({
        extension: "Extension first",
        tag: "Tag first"
      });
      dropdown.setValue(this.plugin.settings.priority || "extension");
      dropdown.onChange(async (value) => {
        this.plugin.settings.priority = value;
        await this.plugin.saveSettings();
        new import_obsidian.Notice(`Priority set to: ${value === "extension" ? "Extension" : "Tag"}`);
      });
    });
    containerEl.createEl("h3", { text: "Extension-to-Folder Mapping" });
    new import_obsidian.Setting(containerEl).setName("Enable Extension Mapping").setDesc("Enable or disable extension-to-folder mapping.").addToggle((toggle) => {
      var _a;
      toggle.setValue((_a = this.plugin.settings.extensionEnabled) != null ? _a : true);
      toggle.onChange(async (value) => {
        this.plugin.settings.extensionEnabled = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const allFolders = this.app.vault.getAllFolders();
    for (const [extension, folder] of Object.entries(this.plugin.settings.folderMapping)) {
      new import_obsidian.Setting(containerEl).setName(`Extension: ${extension}`).setDesc("Change the folder for this extension").addDropdown((dropdown) => {
        dropdown.addOption("", "Select folder...");
        allFolders.forEach((f) => dropdown.addOption(f.path, f.path));
        dropdown.setValue(folder);
        dropdown.onChange(async (value) => {
          if (value) {
            this.plugin.settings.folderMapping[extension] = value;
            await this.plugin.saveSettings();
            new import_obsidian.Notice(`Folder for .${extension} files updated to: ${value}`);
          }
        });
      }).addButton(
        (btn) => btn.setButtonText("Delete").setCta().onClick(async () => {
          delete this.plugin.settings.folderMapping[extension];
          await this.plugin.saveSettings();
          this.display();
        })
      );
    }
    let newExtension = "";
    let newFolder = "";
    new import_obsidian.Setting(containerEl).setName("Add new extension mapping").setDesc("Add a new extension and target folder").addText(
      (text) => text.setPlaceholder("Enter extension (e.g., pdf)").onChange((value) => newExtension = value.trim())
    ).addDropdown((dropdown) => {
      dropdown.addOption("", "Select folder...");
      allFolders.forEach((folder) => dropdown.addOption(folder.path, folder.path));
      dropdown.onChange((value) => newFolder = value);
    }).addButton((btn) => {
      btn.setButtonText("Add").setCta().onClick(async () => {
        if (newExtension && newFolder) {
          this.plugin.settings.folderMapping[newExtension] = newFolder;
          await this.plugin.saveSettings();
          this.display();
        }
      });
    });
    containerEl.createEl("h3", { text: "Tag-to-Folder Mapping" });
    new import_obsidian.Setting(containerEl).setName("Enable Tag Mapping").setDesc("Enable or disable tag-to-folder mapping.").addToggle((toggle) => {
      var _a;
      toggle.setValue((_a = this.plugin.settings.tagEnabled) != null ? _a : true);
      toggle.onChange(async (value) => {
        this.plugin.settings.tagEnabled = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    for (const [tag, folder] of Object.entries(this.plugin.settings.tagMapping)) {
      new import_obsidian.Setting(containerEl).setName(`Tag: ${tag}`).setDesc("Change the folder for this tag").addDropdown((dropdown) => {
        dropdown.addOption("", "Select folder...");
        allFolders.forEach((f) => dropdown.addOption(f.path, f.path));
        dropdown.setValue(folder);
        dropdown.onChange(async (value) => {
          if (value) {
            this.plugin.settings.tagMapping[tag] = value;
            await this.plugin.saveSettings();
            new import_obsidian.Notice(`Folder for ${tag} files updated to: ${value}`);
          }
        });
      }).addButton(
        (btn) => btn.setButtonText("Delete").setCta().onClick(async () => {
          delete this.plugin.settings.tagMapping[tag];
          await this.plugin.saveSettings();
          this.display();
        })
      );
    }
    let newTag = "";
    let tagFolder = "";
    new import_obsidian.Setting(containerEl).setName("Add new tag mapping").setDesc("Add a new tag and target folder").addText(
      (text) => text.setPlaceholder("Enter tag (e.g., #test1)").onChange((value) => newTag = value.trim())
    ).addDropdown((dropdown) => {
      dropdown.addOption("", "Select folder...");
      allFolders.forEach((folder) => dropdown.addOption(folder.path, folder.path));
      dropdown.onChange((value) => tagFolder = value);
    }).addButton((btn) => {
      btn.setButtonText("Add").setCta().onClick(async () => {
        if (newTag && tagFolder) {
          this.plugin.settings.tagMapping[newTag] = tagFolder;
          await this.plugin.saveSettings();
          this.display();
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("Get tag mapping").setDesc("Scan the tag in the file and make mapping tag to folder automatically").addButton((btn) => {
      btn.setButtonText("Start scan").setCta().onClick(async () => {
        await this.plugin.updateTagMappingFromExistingFiles();
        this.display();
      });
    });
  }
};


/* nosourcemap */